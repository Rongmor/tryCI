Поехали

1) Первая программа на Питоне
Открыли IDLE, нажали File -> New, в открывшемся пустом файле написали следующее:

print('Hello world!')

Нажали F5, сохранили файлик под названием helloworld.py и увидели в окошке IDLE (это окошко также называется Shell) следующее:

Hello world!

Это значит что все хорошо и самое страшное позади - мы уже написали первую программу на Питоне. Что в ней происходит - создается строка 'Hello world!', потом вызывается функция print. Ей в качестве аргумента передается созданная строка. Если кратко, то она печатает то, что ей передают в качестве аргумента. Мы будем пользоваться ей на протяжении всех уроков. Она умеет печатать не только строки, но и числа, и многое другое. Поехали дальше.


2) Знакомимся с числами и операциями над ними
В новый файлик numbers.py пишем следующее:

print(2 + 3)
print(2 - 3)
print(2 * 3)
print(2 / 3)
print(2 ** 3)
print(2 % 3)
print(2 // 3)
print(2 == 3)
print(2 != 3
print(2 > 3)
print(2 >= 3)
print(2 < 3)
print(2 <= 3)

Запуская, видим результат и убеждаемся, что умеем считать. Что происходит в этой программке - создаются числа и к ним применяются операторы. Например, оператор + - оператор сложения. Его применение возможно не только к числам - применение к строкам склеивает их, к спискам - тоже склеивает, ко множествам - объединяет их. Поэтому правильно будет назвать + оператором, а то что он делает над числами - это операция сложения. Половина написанных здесь операторов соответствует обозначению в математике, вторая может немного отличаться:

// - целочисленное деление. Результат равен целой части от обычного деления
% - остаток от деления
** - возведение в степень
== - равно 
!= - не равно
>= - больше или равно
<= - меньше или равно

Дописываем следующие строчки:

print(abs(3 - 2))
print(abs(2 - 3))
print(2 / 5)
print(3 / 5)
print(round(2 / 5))
print(round(3 / 5))
print(max(2, 3))
print(max(2, 3, 5))
print(min(2, 3))
print(min(2, 3, 5))

Они демонстрируют работу функций abs, round, min и max, которые имеют вполне очевидные значения:
abs - взятие модуля числа
round - округление
min - минимум из всех чисел (из двух, трех или больше)
max - максимум из всех чисел (из двух, трех или больше)
sum - сумма всех чисел (из двух, трех или больше)

Мы уже видели вещественное число, когда делили 2 на 3. Можно и самому их писать:

print(0.123)
print(0.5 + 0.5)
print(16 ** 0.5)

Длинные выражения с помощью скобок, например, посчитать длину гипотенузы, если катеты равны 3 и 4:

print((3 ** 2 + 4 ** 2) ** 0.5)


3) Создаем переменные
В новом файлике variables.py: (в дальнейшем буду писать только название файла)

variable1 = 3
variable2 = 5
variable3 = variable1 + variable2
print(variable1)
print(variable2)
print(variable3)

над переменными определены еще и следующие операторы:

variable1 = 2
variable1 += 3
print(variable1)
variable1 -= 3
print(variable1)
variable1 *= 3
print(variable1)
variable1 /= 3
print(variable1)
variable1 **= 3
print(variable1)
variable1 //= 3
print(variable1)
variable1 %= 3
print(variable1)

Они изменяют значение переменной на месте, беря ее текущее значение и используя его для операции, иногда это бывает очень удобно. В целом, следущие записи равны: variable += expression и variable = variable + expression

4) Проверка условия
condition.py:

a = 5
b = 10
if a < b:
    print('a < b')
else:
    print('a >= b')

Итак, происходит проверка "правда ли, что а меньше б?". В данном случае это не так, проверка неуспешна, выполнение кода идет в ветку после else и на экран выведется строка 'a < b'. Если поменять друг с другом значения a и b, то выведется другая надпись:

a = 10
b = 5
if a < b:
    print('a < b')
else:
    print('a >= b')

После строчки с проверкой может находиться не одна строчка, а больше. Они называются блоком (одна тоже называется блоком). Также блоком называются строчки до проверки и включая ее, а также строчки после ветки кода, который выполняется после успешной проверки. Таким образом (не для запуска):
блок 1)
a = 10
b = 5
if a < b:
...
else:
блок 2)
    print('a < b')
блок 3)
    print('a >= b')

Блоки 2 и 3 являются внутренними для блока 1. Блок 1 является внешним для блоков 2 и 3. Выполнение кода начинается во внешнем блоке и может переходить во внутренний при некотором условии, в данном случае при успешной проверке if в блок 1 и при неуспешной в блок 2. При достижении конца внутреннего блока выполнение кода продолжается во внешнем. Внутренние блоки должны иметь отступ в 4 пробела относительно внешнего.

Более детальный пример на понимание блоков, с большим уровнем вложенности:

print('block 1 started')
a = 1
b = 2
c = 3
if a < b:
    print('block 2 started from block 1')
    if b < c:
        print('block 3 started from block 2')
        print('a < b < c')
        print('block 3 finished, block 2 continued')
    else:
        print('block 4 started from block 2')
        print('a, b and c are not ordered')
        print('block 4 finished, block 2 continued')
    print('block 2 finished, block 1 continued') 
else:
    print('block 5 started from block 1')
    print('a, b and c are not ordered')
    print('block 5 finished, block 1 continued')
print('block 1 finished')

изменяй значения a, b, c и запускай программку заново, чтобы увидеть выполнение различных блоков.
блоки 2 и 5 внутренние для блока 1.
блоки 3 и 4 внутренние для блока 2.
Таким образом, блоки могут иметь большой уровень вложенности. Заметь, что блоки 2 и 5 имеют отступ в 4 пробела относительно блока 1, а блоки 3 и 4 имеют отступ в 4 пробела относительно блока 2, все по 4 пробела относительно своего внешнего блока.

Разобравшись с блоками, вернемся к проверкам условий. Блок else не является обязательным и можно писать вот так:

a = 2
if a > 0:
    print('a > 0')
print('there is no "else:" block here')

Так, сейчас поставим такую задачу и сразу решим: "Если а меньше 0, написать "отрицательное", иначе если а делится на 2, написать "четное", иначе написать "никакое"". 

a = 10
if a < 0:
    print('отрицательное')
else:
    if a % 2 == 0:
        print('четное')
    else:
        print('никакое')

Немного улучшить это решение может слово elif. Его использование объединяет строчки "else:" и "if a % 2 == 0:":

a = 10
if a < 0:
    print('отрицательное')
elif a % 2 == 0:
    print('четное')
else:
    print('никакое')

Преимуществом является уменьшение вложенности (строки с print сдвинулись влево на 4 пробела). 

Проверки вида "если условие1 и условие2" выполняются с помощью ключевого слова and. Например, проверить что число а больше нуля и меньше десяти:

a = 5
if a > 0 and a < 10:
    print('0 < a < 10')
else:
    print('check failed')

Проверки вида "если условие1 или условие2" выполняются с помощью ключевого слова or. Например, проверить что число а не лежит в диапазоне от нуля до десяти:

a = 5
if a < 0 or a > 10:
    print('a is not in range from zero to ten')
else:
    print(0 <= a <= 10')

Также бывает полезна проверка вида " если условие ложно". Для этого используется ключевое слово not. Например, проверить что а меньше нуля можно так:

a = 5
if not a >= 0:
    print('a < 0')
else:
    print('a >= 0')

такая проверка полностью эквивалентна проверке if a < 0, но повторюсь, использование not может быть более полезным чем в этом примере. 

5) Циклы

Цикл - блок кода, повторяющийся некоторое количество раз: больше одного, ровно один или даже ноль. Первый вариант создания цикла - с использованием ключевого слова while

cyclewhile.py:

a = 0
while a < 5:
    print(a)
    a += 1
print('finish cycle while')

блок кода внутри цикла while выполнится 5 раз, и на экран выведется 5 чисел от 0 до 4. Когда а станет равно 5, условие a < 5 станет ложным, и выполнение кода продолжится во внешнем блоке, а не войдет во внутренний, внутри цикла while. После слова while могут быть записаны точно такие же условия как после if: со словами and, or или not.

Так как циклы основываются на блоках, они также могут быть вложенными:

a = 0
while a < 5:
    b = 0
    while b < 5:
        print(a, b)
        b += 1
    print('cycle on b += 1 finished')
    a += 1
print(cycle on a += 1 finished')

Также они могут комбинироваться с блоками проверки условий. Почему - потому что все это блоки. Не для запуска, но для описания идеи:

while condition:
    code
    if condition:
         code
         if condition:
              code
         else:
              while condition:
                  code
    elif condition:
        code
        while condition:
            code

Выйти из цикла можно раньше чем условие станет ложным. Для этого используется слово break:

a = 0
while a < 5:
    print(a)
    a += 1
    break
print('finish cycle while')

Код цикла будет выполнен только один раз, встретит слово break и выйдет из цикла. Будет написано только одно число 0.

Также существует возможность прервать выполнение внутренного блока цикла и вернуться к проверке условия цикла с помощью слова continue:

a = 0
while a < 5:
    print(a)
    a += 1
    continue
    break
print('finish cycle while')

Код цикла выполнится все 5 раз: при встрече слова continue выполнение кода внутри цикла прекращается и не доходит до слова break. Но и не прекращается весь цикл полностью, а возвращается к проверке a < 5. 

Еще одним вариантом организации цикла является использование следующей конструкции:
for i in range(5):
    print(i)

Сейчас не могу объяснить, как оно работает на самом деле. Только покажу какие есть варианты:
range(a) - i принимает значения от 0 до a-1 включительно
range(a, b) - i принимает значения от a до b-1 включительно
range(a, b, c) - i принимает значения a, a + c, a + 2 * c, ... до того момента, пока a + n * c меньше чем b

Посмотри:
for i in range(100, 205, 10):
    print(i)

к циклам такой конструкции применимы те же правила: можно выйти по break, вернуться к началу цикла по continue, внутри цикла так же находится код который является внутренним блоком, возможна комбинация цикла for с циклом while и проверками условия:

for i in range(a):
    code
    if condition:
        while condition:
            for j in range(b, c, d):
               code

Единственный важный момент: если внутри цикла изменить значение переменной цикла (это та переменная, которая идет после слова for), то это не повлияет на количетсво повторений цикла. Например:

for i in range(10):
    print(i)
    i = 20
    print(i)

значение меняется только во внутреннем блоке и ты можешь использовать новое значение, но потом оно возвращается  

6) Функции

Одним из простых, но самых мощных инструментов в руках программиста является создание собственных функций. Как те, что ты встретил в начале урока, min, max и т.д.

Пример написания собственной функции min для двух чисел:

def mymin(a, b):
    if a < b:
        return a
    else:
        return b

пробуем:

print(mymin(2, 3))
print(mymin(3, 2))

Итак, необходимо написать слово def, название функции, поставить скобку, написать имена - список параметров, закрыть скобку, поставить двоеточие, и все внутри этого блока - тело функции. Функция может вернуть некоторое значение, указанное после слова return. Если слова return нет, то эта функция ничего не вернет. Такие функции все равно могут быть полезны. Например, функция пишет переданную строку в файл и ничего не возвращает - это вполне нормально. Функция может не принимать параметров, такое тоже встречается:

def foo():
    return 42

print(foo())

В таком случае необходимо поставить открывающую и закрывающую скобку вместе. Вызывать также со скобками.

Важно, что при встрече слова return выполнение функции заканчивается. Пример:

def foo():
    a = 5
    while a < 10:
        a += 1
        return a
    return a

print(foo())

Ты увидишь 6, а не 10, потому что при встрече return внутри цикла вернется текущее значение а.

7) Ошибки

Это то с чем ты конечно же столкнешься когда будешь писать код сам, не копируя из уроков. Посмотрим на самые часто встречающиеся. Их не надо запоминать, просто прочти один раз и будь готов к тому что ты их еще встретишь. Потом само запомнится.

1. Invalid syntax

Возникнет при запуске этого кода:

a = 5
if a < 5:
    print(a))

в последней строчке лишняя скобка. На самом деле, это ошибка может возникать во многих случаях, не только из-за скобок. Хорошо то что их достаточно легко исправить, потому что idle выделит строку в которой ошибка, или даже ошибочный символ в этой строке в случае скобки. Также ее можно получить вот так:

a = 5
if a < 5
    print(a)

в строке if a < 5 отсутствует двоеточие. Ну и еще много как

2. Expected an indent block

a = 5
if a < 5:
print(a)

Возникнет, если ты не отделил внутренний блок от внешнего четыремя пробелами. Кстати, idle устроена так, что нажатие Таба ставит вместо таба 4 пробела, что очень удобно. Также, когда ты напишешь строчку if a < 5: и нажмешь Enter 4 пробела появятся на следующей строчке автоматически. Поэтому такую ошибку очень сложно получить, работая в idle

3. Unexpected indent

a = 5
 if a < 5:
    print(a)

Когда строчки в одном блоке имеют разное количество начальных пробелов, тоже возникает ошибка

4. Unundent doent match any outer indentation level

a = 5
if a < 5:
    if a < 5:
        print(a)
       print(a)

Когда строчка во внутреннем блоке имеет меньше пробелов, чем предыдущая, идет попытка перехода в какой-либо внешний блок. Но количество пробелов в последней строчке не совпадает ни с одним из внешних блоков и возникает ошибка. Возможные совпадения:

a = 5
if a < 5:
    if a < 5:
        print(a)
    print(a)

a = 5
if a < 5:
    if a < 5:
        print(a)
print(a)

5. ZeroDivisionError

Название говорит само за себя и получить такую ошибку очевидно можно вот так:

print(1/0)

6. TypeError

Возникает во многих случаях, например когда ты передал неправильное количество параметров в функцию:

def foo(a, b):
    return a + b

print(foo(1, 2, 3))

TypeError: foo() takes 2 positional arguments but 3 were given

Также нельзя использовать дробные числа в цикле for:

for i in range(1.5):
    print(i)

TypeError: 'float' object cannot be interpreted as an integer

7. NameError

Ты пытаешься использовать переменную b, которую еще не определил:

a = 5
print(b)

NameError: name 'b' is not defined

8. Бесконечный цикл.

Тут сложнее всего, потому что сообщения об ошибке ты не увидишь. Пример:

a = 0
while a < 10:
    a -= 1
print(a)

Ты не увидишь и результат вызова print(a). Если попал в такой цикл - нажимай либо ctrl-C, либо ctrl-F6, либо в окошке shell'a Shell -> Restart Shell

Кстати говоря иногда бывает полезно организовать бесконечный цикл специально, комбинируя его с выходом по break. Для этого используется такая конструкция:

while True:
    code
    if condition:
        break
код продолжает выполняться здесь, так как выходит из бесконечного цикла

Насчет True. Так как переводится на русский как "правда", "истина", то проверки вида if True: и while True: всегда являются успешными. Также можешь написать такое:

print(1 < 2)

проверка 1 < 2 вернула True - единица и правда меньше двойки. Если написать такое:

print(2 < 1)

то увидишь False - "ложь". Поэтому блок кода в следующей конструкции никогда не сработает:

if False:
    code

True и False можно присваивать переменным и возвращать из функций и пользоваться также как и любым другим значением:

def foo():
    a = True
    if a:
        return True
    return False

f = foo()
print(f)

КОНЕЦ

А кто слушал - молодец. Того что здесь написано должно хватить, чтобы ты справился с первыми заданиями:
Написать функции, которые:
1) Считает минимум из трех чисел a, b, c
2) Считает факториал числа n
3) Считает n-ое число Фибоначчи
4) Считает сумму цифр числа n
5) Проверяет, является ли число n простым
6) Проверяет, является ли число палиндромом
открываем https://projecteuler.net/, регаемся если еще не.
решаем задачки 1, 2, 3, 4, 5, 6, 7, 9, 15, 16, 20
Некоторые из них могут выполняться чуть-чуть долго, около минуты. Если больше двух-трех минут - скорее всего ты попал в бесконечный цикл.
